type ZapInteraction @entity(immutable: true) {
  id: Bytes!
  user: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  
  wldAmount: BigInt!
  usdcReceived: BigInt!
  conditionId: Bytes!
  outcomeIndex: BigInt!
  sharesReceived: BigInt!
  protocolFee: BigInt!
}

type MarketProposal @entity {
  id: Bytes!
  creator: Bytes! # address
  question: String!
  description: String
  outcomes: [String!]
  resolutionCriteria: String
  category: String
  
  status: ProposalStatus!
  votingEndsAt: BigInt!
  createdAt: BigInt!
  
  votesFor: BigInt!
  votesAgainst: BigInt!
  totalVotes: BigInt!
  
  votes: [Vote!]! @derivedFrom(field: "proposal")
  royaltyAccruals: [RoyaltyAccrual!]! @derivedFrom(field: "proposal")
}

enum ProposalStatus {
  VOTING
  APPROVED
  REJECTED
  CREATED
}

type Vote @entity(immutable: true) {
  id: Bytes!
  proposal: MarketProposal!
  voter: Bytes! # address
  support: Boolean! # true = FOR, false = AGAINST
  weight: BigInt!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type RoyaltyClaim @entity(immutable: true) {
  id: Bytes!
  distributor: Bytes! # address
  claimer: Bytes! # address
  period: BigInt!
  amount: BigInt!
  timestamp: BigInt!
  transactionHash: Bytes!
}

type RoyaltyAccrual @entity(immutable: true) {
  id: Bytes!
  proposal: MarketProposal!
  amount: BigInt!
  timestamp: BigInt!
}

type MerkleDistribution @entity(immutable: true) {
  id: Bytes! # merkle root
  period: BigInt!
  totalAmount: BigInt!
  publishedAt: BigInt!
  expiresAt: BigInt!
  creator: Bytes! # address
}
